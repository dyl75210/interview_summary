# 简历相关

## 自我介绍

尊敬的面试官您好，我叫xxx，很高兴能参加这次面试，目前就读于华中科技大学机械科学与工程学院，实验室是国家智能设计与数控技术创新中心，本科是机械设计及其自动化专业，研究生的研究方向是机床空间误差的测量与补偿。在本科期间通过金工实习学习了机床和数控系统的操作，硕士阶段进一步学习了数控系统的相关知识。在实验室做的主要项目是开发数控系统中对空间误差进行补偿的模块，项目背景是客户机床厂需要提高五轴机床加工精度，我们组是专注于提升机床精度的，机床的几何误差影响五轴机床高精度加工的重要因素，我的任务就是开发这个模块的内核补偿模块和可视化界面，推导补偿公式，最后进行实际的补偿验证，几何误差显著减少。在开发的过程中学习了c和c++的相关知识并进行了应用，更深入理解数控系统的内核，在实现项目过程中培养了团队协作和沟通能力，能适应迭代式开发节奏。

## JSON parser generator

### 项目简介

goa-json是一款基于C++17开发的header-only JSON解析/生成器，采用递归下降的方式进行解析，支持`DOM(Document Object Model)`和`SAX(Simple API for XML)`两种API风格:

- `DOM`是一种基于树状结构的JSON解析模型。在DOM解析中，整个JSON文件被加载到内存中并表示为一个树状结构的对象模型，JSON中的每个元素都对应一个节点，这些节点可以通过编程接口进行访问、遍历和修改。DOM解析允许应用程序以树状结构的方式直接操作JSON数据，但可能需要更多的内存和计算资源，尤其是对于大型文档。DOM的优点是易于编写代码和操作，特别适用于需要频繁随机访问JSON数据的情况。
- `SAX`是一种基于事件的JSON解析模型。在SAX解析中，JSON文档被顺序解析，当解析器遇到特定的JSON元素或事件（如开始标签、结束标签、文本内容等）时，它会触发相应的事件，从而允许应用程序在处理过程中做出响应。SAX解析器一次只解析文档的一部分，因此适用于处理大型JSON文档，因为它不需要将整个文档加载到内存中。SAX的优点是效率高，占用的内存少，但在代码编写上通常需要更多的处理逻辑。

以如下JSON字符串为例：

```
{
    "hello": "world",
    "t": true ,
    "f": false,
    "n": null,
    "i": 123,
    "pi": 3.1416,
    "a": [1, 2, 3, 4]
}
```

其DOM树构建为：

<img src="D:/interview/interview_summary/image/项目相关_image/DOM树.png" alt="DOM树" style="zoom:50%;" />

### 项目架构

goa-json定义有三个核心concept，分别是`ReadStream`、`WriteStream`和`Handler`:

- `ReadStream`用于读取字符流，目前实现了`StringReadStream`和`FileReadStream`分别用于从内存和文件中读取字符。
- `WriteStream`用于输出字符流，目前实现了`StringWriteStream`和`FileWriteStream`分别用于向内存和文件中输出字符。
- `Handler`是解析和生成时，用于事件触发和执行的对象，目前实现了SAX风格的`Writer`用于向`WriteStream`输出字符，以及DOM风格的`Document`用于构建JSON对象的树形存储结构。

其中，`ReadStream`和`WriteStream`的实现只能为`StringXXX`和`FileXXX`，通过`enable_if_t`进行编译期模板参数类型检查；`Handler`除现有实现外，支持自定义，以进行定制化操作。

<img src="D:/interview/interview_summary/image/项目相关_image/架构UML类图.png" alt="架构UML类图" style="zoom: 67%;" />

关系的核心是`Handler`概念。在SAX一边，`Reader`从流解析JSON并将事件发送到`Handler`。`Writer`实现了`Handler`概念，用于处理相同的事件，并将解析结果传入输出流。在DOM一边，`Document`实现了`Handler`概念，用于通过这些事件来构建DOM。在这个设计，SAX是不依赖于DOM的。甚至`Reader`和`Writer`之间也没有依赖。这提供了连接事件发送器和处理器的灵活性。除此之外，`Value`也是不依赖于SAX的。所以，除了将DOM序列化为JSON之外，用户也可以将其序列化为XML，或者做任何其他事情。

### 值（Value类）

goa-json中自定义了可变类型数据存储类`Value`，其设计类似于QT中的QVariant和C++17中的Variant，json文档中的每一个元素（DOM树状结构上的叶子节点或子树）都可以用`Value`来存储，是DOM API的核心。其内部维护一个union来存储数据并节约存储空间，xxx：

```c++
using StringWithRefCount =
  AddRefCount<std::vector<char>>;  // json string类型 保存字符串
using ArrayWithRefCount =
  AddRefCount<std::vector<Value>>;  // json array类型 保存json值
using ObjectWithRefCount =
  AddRefCount<std::vector<Member>>;  // json object类型 保存键值对
union {
    bool                b_;
    int32_t             i32_;
    int64_t             i64_;
    double              d_;
    StringWithRefCount* s_;
    ArrayWithRefCount*  a_;
    ObjectWithRefCount* o_;
};
```

并使用`enum class`定义了`ValueType`来表示当前`Value`的类型，防止命名空间污染：

```
enum class ValueType {
    TYPE_NULL,
    TYPE_BOOL,
    TYPE_INT32,
    TYPE_INT64,
    TYPE_DOUBLE,
    TYPE_STRING,
    TYPE_ARRAY,
    TYPE_OBJECT
};
```

`Value`内部定义了`isXXX()`、`getXXX()`和`setXXX([args])`，分别用来判断类型、访问成员和修改成员（XXX可为Null、Bool、Int32、Int64、Double、String、Array和Object）。其中getXXX()中对类型断言判断以进行类型检查，若Value本身类型与getXXX()类型不一致，在Debug模式下将因断言失败而崩溃。

### 相关问题

#### 如何设计Read WriteStream

- `ReadStream`用于读取字符流，目前实现了`StringReadStream`和`FileReadStream`分别用于从内存和文件中读取字符。

  `StringReadStream`接受`std::string_view`作为参数，获取字符串的视图

  `FileReadStream`接受FILE指针，读取文件并使用`vector<char>`保存字符串

  他们内部包含一个迭代器供访问数据，以及提供了`next()  hasNext() peek()`等接口

- `WriteStream`用于输出字符流，目前实现了`StringWriteStream`和`FileWriteStream`分别用于向内存和文件中输出字符。

  StringWriteStream内部包含一个vector<char> , 可向其中写数据

  FileWriteStream内部包含FILE指针，可向文件写数据

  他们提供了重载的put()接口，输入单个字符或者一个字符串

#### 如何解析json  

![image-20250520174348038](D:/interview/interview_summary/image/项目相关_image/image-20250520174348038.png)

**解析的核心是Reader类**，支持从StringReadStream和FileReadStream中读取并解析

JSON支持以下几种基本数据类型：

1. **字符串**（String）：用双引号 `""` 包裹的文本。

   ```
   "Hello, World!"
   ```

2. **数字**（Number）：可以是整数或浮点数。

   ```
   -456,
   0.001,
   1.23e10,
   -4.56E-2
   ```

3. **布尔值**（Boolean）：`true` 或 `false`。

4. **数组**（Array）：一组值的有序集合。

   ```
   [1, 2, 3]
   ```

5. **对象**（Object）：由键值对组成的无序集合。

   ```
   {"key1": "value1",
    "key2":"value2"}
   ```

   ==object的value还可以是json的各种数据类型    object套object可以实现嵌套==

6. **空值**（Null）：表示空值或不存在的值。

   ```
   null
   ```

采用**有限状态机和递归下降解析**，null以n开头，true和false以n或f开头，字符串以“开头，array以[开头，object以{开头，其余则表示数字

根据上述类型进行解析，同时进行处理，处理有两种，一种称为SAX风格，即遇到需要处理的json数据后执行处理逻辑，还可以对执行结果进行输出。

一种称为DOM风格，即在内存中构建树状json模型，解析完毕后可以对其进行访问和修改。

处理用到了另一个模块Handler，其是一个接口类，本质是提供对解析的数据（如数字、字符串）的处理。

本项目中的Writer类和Document类实现了这一接口，前者利用StringWriteStream和FileWriteStream将数据进行输出，后者用于构建json树状模型。

#### 如何处理解析的结果 handler

![image-20250520174522073](D:/interview/interview_summary/image/项目相关_image/image-20250520174522073.png)

handler是一个接口类，提供上图的接口。

在Writer和Document类中实现了这些接口。

#### SAX和DOM的区别

主要区别在于是否在内存中构建json树状结构，提供内存的json数据的访问和修改接口。

这涉及大型和中小型json文件解析方式的选择，大型文件使用DOM方式解析会占用较大内存。

#### 如何在内存中保存json(DOM)  value document类

核心是value和document类。

##### value

value提供了json树状结构的基本抽象，document提供了基于value的对json树状模型的构建。

value支持下图几种ValueType，提供了isXXX、getXXX方法进行类型判断和访问，对array类型提供了operator[i]重载和addValue方法添加元素，对object提供了beginMember、endMember、findMember、operator[]、addMember等方法进行访问、查找和修改。

![image-20250520175022092](D:/interview/interview_summary/image/项目相关_image/image-20250520175022092.png)

在数据保存上，采用union保存几种类型的数据，节省空间。其中xxxWithRefCount的底层实现是vector。

![image-20250520175703747](D:/interview/interview_summary/image/项目相关_image/image-20250520175703747.png)

![image-20250520175822609](D:/interview/interview_summary/image/项目相关_image/image-20250520175822609.png)

##### document

在document一边，基于value实现了handler的接口。其核心函数是addValue，通过维护一个栈，在构建array和object开始时，startxxx会构造一个Value入栈，之后继续解析，并向栈中的父Value其中添加单个或者kv类型的子Value数据，构建完毕后，由endxxx进行出栈。最终返回一个完整了树状结构。

Reader在parseArray和parseObject时，会调用上述startxxx和endxxx接口。

![image-20250520174407410](D:/interview/interview_summary/image/项目相关_image/image-20250520174407410.png)





## EV

### 项目简介

goa-ev是一款基于C++20开发的适用于Linux的事件驱动型多线程网络库，附带有日志、定时器、线程池模块，只依赖STL，无第三方依赖。日志模块使用了C++20标准库中的**format**来进行格式化输出，也是整个项目唯一依赖C++20的模块，其余部分均依赖于C++11实现。参考陈硕的muduo网络库，基于one loop per thread搭配线程池的方式实现multi-reactor架构。

### 项目架构

<img src="D:/interview/interview_summary/image/项目相关_image/1.png" alt="1" style="zoom:20%;" />

goa-ev的核心架构如上图所示，其核心模块为Channel，EPollPoller和EventLoop。服务端为一个**TcpServer**实例，该实例中可包含有多个**TcpServerSingle**实例，每个**TcpServerSingle**实例都对应有一个**EventLoop**，运行在一个独立线程中，其通过调用loop监听和处理事件。每个**TcpServerSingle**都包含有独立的**Acceptor**负责监听同一个服务器端口，并在连接到来时通过调用**newConnectionCallback**来对连接事件进行处理。该回调函数由**TcpServerSingle**传入**Acceptor**，负责建立连接对象**TcpConnection**。当客户端连接请求到来时，若有多个**Acceptor**监听同一个服务器端口（已开启**SO_REUSEPORT**选项），则由操作系统采用相对公平的方式决定将连接分配给哪个线程，从而实现负载均衡。

### 子模块

#### 日志的实现

设置日志等级  

使用std::format  格式化输出

使用std::osyncstream 保证线程安全，保证单个输出操作是原子的（不会被其他线程的输出打断），确保来自不同线程的输出不会相互交错

#### 定时器的实现 

主要是由Timer和TimerQueue类实现

```
  using Entry = std::pair<Timestamp, Timer*>;
  using TimerList = std::set<Entry>;
```

TimerQueue使用set保存Timer，每个Timer有自己的回调函数，并定义了是否周期触发，set由红黑树实现，头部的Timer的timestamp最小

每个eventloop中含有TimerQueue，TimerQueue有自己的timerfd_和timerlist，并提供了addTimer、cancelTimer、getExpired、handleRead接口 

用epoll监听timerfd（ **Linux 提供的一种定时器接口**），定时器到期之后，会有可读事件，调用handleRead函数（该函数调用getExpired，对到期Timer进行处理）



#### Server的实现

三个主要模块Channel，EPollPoller和EventLoop。

##### Channel

channel对fd进行管理，并被分配给特定的eventLoop监听。其主要成员有fd对应感兴趣event类型和发生的event类型，以及event对应的回调函数。	其提供接口修改感兴趣的事件、根据事件调用回调函数。

每个fd对应一个channel， fd有三类：服务端监听fd、连接建立后的连接fd和定时器fd，分别对应 Acceptor、TcpConnection和TimeQueue三个类。类中其都包含自己的channel成员。

Acceptor对服务器监听套接字fd及其相关方法进行封装（listen、setNewConnectionCallback、handleRead处理新连接并调用callback）

每个TcpServerSingle都相同的Acceptor，监听相同的端口，交给epoll监听，并通过newConnectionCallback_处理新的连接，newConnectionCallback会建立Tcpconnection实例，并设置Tcpconnection的回调。Tcpconnection在初始化时会设置自己对应的channel的回调，实际是将上层传递给TcpConnection的回调继续传递给channel。

TcpConnection对连接套接字fd及其相关方法进行封装，初始化时将自己的handleXXX函数设置为对应channel的对应事件的回调函数。TcpConenction的成员中除了xxxCallbacks还有inputBuffer和outputBuffer，handlerRead会将数据从内核缓存区读入inputBuffer，并提供了send接口，send的底层是sendInLoop，由管理TcpConnection的loop所在的线程处理send任务。sendInLoop会将数据从用户缓存区发到内核缓存区，当内核缓存区满时会将数据暂存到outputBuffer同时监听可写事件，当内核缓存区有空闲空间时，将outputBuffer中的数据继续发送。

##### EPollPoller

EpollPoller负责管理channel   监听感兴趣事件，提供poll、updateChannel接口，获取事件，更新监听类型。

其调用epoll_wait epoll_ctl等系统调用接口

##### EventLoop

每个TcpServerSingle有自己对应的eventloop实例，即one loop per thread。EventLoop含有poller、pendingTasks_、timerQueue，activeChannels，通过loop调用poller监听fd获取activeChannels，执行channel所管理的callback函数，之后处理上层添加的tasks。

EventLoop提供了对TimerQueue的添加接口，提供了对pendingTasks的添加接口queueInLoop。上层可对EventLoop添加task（调用runInLoop和queueInLoop），当调用接口的线程为loop线程时，则直接执行，否则加入pendingTasks。

注意epoll_wait在没有事件发生时会阻塞，EventLoop设置了一个wakeupChannel并交给epoll监听，当pendingTasks不为空时，会通过wakeupfd唤醒epoll，使其顺利执行doPendingTasks。

##### 过程

服务端为一个**TcpServer**实例，该实例中可包含有多个**TcpServerSingle**实例，每个**TcpServerSingle**实例都对应有一个**EventLoop**，运行在一个独立线程中，其通过调用loop监听和处理事件。

每个**TcpServerSingle**都包含有独立的**Acceptor**负责监听同一个服务器端口，并在连接到来时通过调用**newConnectionCallback**来对连接事件进行处理。**TcpServerSingle**为每个新连接建立TcpConnection实例，放入自己管理的**ConnectionSet**中，同时设置tcp连接fd的回调函数。

##### 非阻塞IO LT触发

通过`  ::accept4(acceptfd_, reinterpret_cast<sockaddr*>(&addr), &len,SOCK_NONBLOCK | SOCK_CLOEXEC);`建立非阻塞IO的连接，同时epoll的监听采用水平触发LT（默认行为）。

当可读时，handlerRead会从内核缓存区读取数据到用户缓存区然后返回，buffer读取时，采用extrabuf尽可能多的读取数据，减少LT下的可读事件触发次数从而减小可读次数。

IO的阻塞和非阻塞是指，阻塞状态下read会一直等待有可读数据，之后拷贝并返回，非阻塞read指不管内核缓存区有没有数据就绪，有就读取并返回，没有就立即返回-1。

#### 线程池的实现  

线程池是一个独立的模块 基于生产者消费者模型实现

维护一个taskqueue  所有进程循环执行take，从队列中取出任务。 其他模块在外围通过runTask添加task

使用std::promise和std::future获取结果

- **std::promise**: 承诺在未来某个时间点提供一个值
- **std::future**: 用于获取 promise 设置的未来值

下面的addoneServer的示例   线程池负责执行addone任务

```c++
    std::promise<long long> res_promise;  // 线程间通信 获取结果
    std::future<long long> res_future = res_promise.get_future();

    // 利用线程池执行计算任务
    threadPool_.runTask([&]() {
      long long oldNum = std::stoll(buffer.retrieveAllAsString());
      int ttid = static_cast<pid_t>(syscall(SYS_gettid));
      buffer.append("calculation handled by tid " + std::to_string(ttid) +
                    ": ");
      res_promise.set_value(oldNum + 1);
    });

    std::string res = std::to_string(
        res_future.get());  //调用res_future.get()会阻塞，等待线程池的计算结果
```

### 相关问题

##### reactor网络模式

市面上常见的开源软件很多都采用了这个方案，比如 Redis、Nginx、Netty 等等

核心是， **I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程**。

Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成，它俩负责的事情如下：

- Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；
- 处理资源池负责处理事件，如 read -> 业务逻辑 -> send；

##### 用到了c20的什么

std::format  vformat

## RPC

### 项目简介

goa-rpc是一款基于C++20开发的使用于Linux的RPC（Remote Procedure Call）框架，使用JSON数据格式作为序列化/反序列化方案，实现了JSON-RPC 2.0协议。客户端支持异步RPC调用，也可以通过线程同步达到同步RPC调用的效果。服务端支持基于线程池的多线程RPC，以提高IO线程的响应速度和处理能力上限。服务采用service.method的命名方式，一个TCP端口可以对外提供多个service，每个service中可以含有多个method。

### 项目架构

<img src="D:/interview/interview_summary/image/项目相关_image/architecture.png" alt="architecture" style="zoom:10%;" />

本项目编译生成的文件中包含有一个stub generator，可以根据spec.json中对一组rpc request和response的完整描述（serviceName,methodName,参数名和类型），自动生成client端和server端的stub代码。使用时client端（RPC调用方）只需包含生成的ClientStub头文件即可获取到相应的RPC服务，server端（RPC被调用方）除了要包含生成的ServiceStub头文件外，还需实现所提供的RPC服务的具体函数逻辑。

goa-RPC中的JSON序列化与反序列化模块基于[GOA-JSON](https://github.com/tianhang-Z/goa-json)实现，网络模块基于[GOA-EV](https://github.com/tianhang-Z/goa-ev)实现。goa-JSON的测试依赖于googletest和benchmark，除此之外无其他依赖。

### 模块实现

服务采用service.method的命名方式，一个TCP端口可以对外提供多个service，每个service中可以含有多个method。

每个method都有自己的callback函数

### 相关问题

##### 通信格式

```cpp
/* message有header和body两部分组成
header: body的长度
body: response + crlf分隔符

内存分布：header + "\r\n" + body + "\r\n"
服务端和客户端都按这个格式收发信息
*/
```

##### 序列化和反序列化

序列化（Serialization）
是将数据结构或对象转换成一种可存储或可传输格式的过程。在序列化后，数据可以被写入文件、发送到网络或存储在数据库中，以便在需要时可以再次还原成原始的数据结构或对象。序列化的过程通常涉及**将数据结构转换成字节流**或类似的格式，使其能够在不同平台和编程语言之间进行传输和交换。

反序列化（Deserialization）
是序列化的逆过程，即将序列化后的数据重新还原成原始的数据结构或对象。反序列化是从文件、网络数据或数据库中读取序列化的数据，并将其转换回原始形式，以便在程序中进行使用和操作。

##### rpc2.0协议以及RPC通信原理



##### 同步和异步RPC调用



##### 什么是stub 如何自动生成

## 华中 8 型数控系统空间误差补偿功能模块开发

### 项目介绍

针对华中数控系统误差补偿落地难、实时性要求高（1ms 响应）、操作复杂等痛点，开发全链路补偿模块。

### 相关问题

#### 内存池预分配

在 VCS 误差补偿项目中，为解决 1ms 实时周期下动态内存分配耗时波动的问题，我在系统初始化阶段就基于华中 8 型 SDK 预分配了三类内存池 —— 包括存储西门子 VCS 表数据的缓存（支持 5 轴 ×1002 测点）、插值计算的中间变量区，以及补偿值输出缓冲区。预分配的内存通过全局指针供通道实时任务（如 chan_comp_calcu）直接调用，不仅把数据读写耗时从 0.8ms 压到 0.1ms 以内，还避免了内存碎片，支撑机床连续 72h 稳定加工，最终满足成飞龙门机床等项目的实时性要求

#### 1. 预分配时机：绑定系统初始化流程

在华中 8 型系统内核初始化阶段（而非补偿任务运行时），调用系统专属内存申请接口（非标准 C 的`malloc`，因内核态开发限制），一次性预分配三类内存块，具体规格结合项目需求设计：

| 内存块类型       | 用途                                     | 预分配大小计算逻辑                                           | 数据结构封装                                                 |
| ---------------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 误差表数据缓存   | 存储导入的西门子 VCS 表数据（.spf 格式） | 单轴最大测点 1002 × 5 轴（最大联动数） × 2（指令位置 + 误差值）× 8 字节（double）= ~80KB | `struct VCS_Table_Buf { double cmd_pos[5][1002]; double error_val[5][1002]; }` |
| 插值计算中间缓存 | 临时存储插值测点索引、插值系数           | 5 轴 × 3（Num/Num+1 测点索引 + 插值权重）× 4 字节（int/float）= ~60B | `struct Interp_Tmp { int num[5]; float weight[5]; }`         |
| 补偿值输出缓冲区 | 暂存最终补偿值（待输出到伺服系统）       | 5 轴 × 1（补偿值）× 8 字节（double） + 校验位（4 字节）= ~44B | `struct Comp_Out_Buf { double comp_val[5]; uint32_t crc; }`  |

#### 2. 访问逻辑：全局指针 + 无锁操作

- 预分配完成后，将内存块地址存入全局指针（如`g_vcs_table_buf`、`g_interp_tmp`），供通道实时任务（`chan_comp_calcu`）、轴内计算函数（`kcomp_chan_comp`）直接访问，避免运行时地址查找耗时；
- 因补偿任务是**单线程实时调度**（华中 8 型系统内核实时任务优先级最高），无需加锁，进一步减少访问延迟（比加锁方案耗时降低 0.1~0.2ms）。

#### 3. 复用与释放：生命周期绑定系统

- 内存池在系统启动时创建，直到系统关机才释放，避免运行时频繁申请 / 释放；
- 误差表数据缓存支持 “覆盖写入”：当导入新的 VCS 表时，直接将新数据写入预分配的缓存块，无需重新分配内存，适配 “一键导入” 功能的高频操作场景。

#### 1. 核心定义

内存池（Memory Pool）是一种**提前申请、统一管理、重复复用**的内存管理机制：在程序 / 模块启动初期，一次性向操作系统（或内核）申请一块连续的 “大内存块”，后续程序对内存的需求（如存储数据、创建对象）不再直接调用系统动态内存接口（如`malloc`/`free`、内核态`kmalloc`），而是从预申请的 “大内存块” 中划分小块分配；释放时也不直接归还给系统，而是标记为 “空闲” 供后续复用。

内存池的实现遵循 “**预分配→分配→释放→销毁**” 的生命周期，每个阶段都有明确的技术逻辑，以下结合工业软件（如数控系统内核）的特性展开：

#### 步骤 1：内存池初始化（预分配阶段）—— 项目中 “系统启动时执行”

这是内存池的 “奠基步骤”，核心是**确定内存池的 “总量、划分规则、管理结构”**，在 VCS 项目中对应 “华中 8 型系统内核初始化阶段”。

1. **需求评估：确定内存池规格**
   先明确业务需存储的数据类型、最大容量，避免预分配过大（浪费内存）或过小（不够用）。
   例：你在 VCS 项目中预分配的三类内存池，就是基于需求评估：

   - 误差表数据缓存：需存储 5 轴 ×1002 测点 ×2（指令位置 + 误差值）= 10020 个`double`（8 字节 / 个），总大小 = 10020×8=80160 字节（≈80KB）；
   - 插值中间缓存：需存储 5 轴 ×3 个参数（测点索引 + 权重）=15 个`int/float`（4 字节 / 个），总大小 = 60 字节；
   - 补偿值输出缓冲区：5 个`double`+1 个`crc`（4 字节）=44 字节。

2. **申请 “大内存块”：调用系统接口**
   根据评估的总大小，调用系统 / 内核的 “一次性内存申请接口”（非动态分配），获取一块连续的物理内存。

   - 用户态程序：通常调用`mmap`（映射一块连续虚拟内存）或`new[]`（申请连续数组）；
   - 内核态程序（如 VCS 项目）：调用工业系统专属接口（如华中 8 型内核的`hnc_mem_alloc`），因内核态禁用`malloc`，需通过系统启动时的 “内存预留接口” 申请，确保内存物理连续（实时系统要求）。

3. **划分 “子内存块”：定义分配单元**
   将预申请的 “大内存块” 按业务需求划分为 “最小分配单元”（即 “子块”），常见两种划分方式：

   | 划分方式     | 原理                                                         | 项目适配场景（VCS 项目用哪种？）                             |
   | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 固定大小子块 | 所有子块大小相同（如统一划分为 32 字节 / 64 字节），适合存储固定长度数据（如`double`、结构体） | ✅ 适配：误差表（`double`固定 8 字节）、插值参数（`int`固定 4 字节），分配 / 释放效率极高 |
   | 可变大小子块 | 子块大小按需求动态调整（如 “空闲块链表” 按大小排序），适合存储变长数据（如字符串） | ❌ 不适合：VCS 项目数据均为固定结构，可变子块会增加耗时，破坏实时性 |

4. **创建 “管理结构”：记录内存状态**
   为了跟踪每个子块的 “空闲 / 已分配” 状态，需设计管理数据结构（通常是链表或位图），这是内存池的 “大脑”。
   例：VCS 项目中可能用 “空闲链表” 管理：

   - 定义结构体`FreeBlock`：包含 “当前子块地址”“子块大小”“下一个空闲子块指针”；
   - 初始化时，将所有子块通过`FreeBlock`链接成 “空闲链表”，表头存储在全局变量（如`g_free_list`）中。

#### 步骤 2：内存分配（运行时阶段）—— 项目中 “补偿计算时调用”

当程序需要内存（如 VCS 项目中 “导入西门子 VCS 表”“计算插值”）时，从内存池中 “申请子块”，核心是**快速找到 “匹配大小的空闲子块” 并标记为已分配**。
以 VCS 项目 “存储单轴误差表数据” 为例（需分配 1002 个`double`，共 8016 字节），分配流程如下：

1. **请求接收**：业务模块（如 VCS 解析模块）调用内存池的分配接口（如`vcs_mem_alloc(size=8016)`），传入所需内存大小；

2. **空闲块匹配**：内存池遍历 “空闲链表”，找到 “大小≥请求大小” 的子块（因 VCS 项目用固定大小子块，直接匹配 8 字节 ×1002 的子块组）；

3. 标记与返回

   ：

   - 若子块大小恰好匹配：从 “空闲链表” 中移除该子块，标记为 “已分配”，返回子块的起始地址（如误差表数据缓存的`cmd_pos`数组地址）；
   - 若子块大小大于请求（少见，固定子块方案中避免）：将子块 “拆分” 为 “已分配块” 和 “新空闲块”，新空闲块重新加入链表；

4. **异常处理**：若无足够空闲子块（如 VCS 项目中 “单轴测点超 1002”），返回 “分配失败” 并触发告警（项目中 “弹窗提示” 功能）。

**关键优化**：在 VCS 项目中，你可能进一步做了 “按数据类型绑定子池”—— 为误差表、插值缓存、输出缓冲区分别创建独立的 “子内存池”，分配时直接访问对应子池，无需遍历所有空闲块，耗时从 “微秒级” 进一步降至 “纳秒级”，满足 1ms 实时周期。

#### 步骤 3：内存释放（运行时阶段）—— 项目中 “覆盖写入时触发”

当程序不再需要某块内存（如 VCS 项目中 “导入新的 VCS 表，替换旧数据”）时，不直接归还给系统，而是标记为 “空闲” 供后续复用，核心是**避免频繁与系统交互**。
以 VCS 项目 “更新误差表数据” 为例，释放流程如下：

1. **释放请求**：业务模块调用内存池的释放接口（如`vcs_mem_free(ptr)`），传入需释放的子块地址；
2. **状态标记**：内存池根据地址找到对应的子块，将其状态从 “已分配” 改为 “空闲”，并重新加入 “空闲链表”；
3. **空闲块合并（可选）**：若释放的子块与相邻子块均为 “空闲”，则合并为 “大空闲块”（避免内部碎片），但在 VCS 项目的 “固定大小子块” 方案中，因子块大小统一，无需合并（直接标记即可）；
4. **复用优先**：下一次申请相同大小的内存时，内存池优先分配 “最近释放的空闲子块”（如 VCS 项目中 “新 VCS 表直接覆盖旧表的空闲子块”）。

**项目特殊处理**：在 VCS 项目中，你可能设计了 “无显式释放” 逻辑 —— 因误差表、补偿值等数据的生命周期与 “补偿任务周期” 绑定，无需单独释放，只需在 “新数据导入时覆盖旧数据的内存块”，进一步简化逻辑、减少耗时（省去释放标记步骤）。

#### 步骤 4：内存池销毁（生命周期结束）—— 项目中 “系统关机时执行”

内存池的销毁仅在 “程序 / 系统退出时” 执行，核心是**将预申请的 “大内存块” 归还给系统**，避免内存泄漏。

- 用户态程序：调用`munmap`或`delete[]`，释放预申请的连续内存；
- 内核态程序（VCS 项目）：调用华中 8 型内核的`hnc_mem_free`接口，将预分配的内存归还给内核内存管理模块；
- 注意：若系统是 “长期运行不关机”（如数控系统通常连续运行数月），内存池可能 “永不销毁”，但因预分配大小固定且复用机制完善，不会导致内存泄漏（这也是 VCS 项目能支持 “连续 72h 运行” 的原因）。

### 三、VCS 项目中内存池预分配的 “定制化实现”（原理落地细节）

通用原理需结合项目场景调整，你在 VCS 项目中针对 “数控系统内核、多项目适配、实时补偿” 的需求，做了 3 点关键定制，这也是体现你技术深度的核心：

#### 1. 绑定 “内核初始化” 的预分配时机

华中 8 型数控系统内核在 “启动阶段”（非运行时）允许申请连续内存，而运行时（如补偿任务执行中）禁用动态分配（避免中断实时任务）。因此你将内存池初始化逻辑放在 “内核模块加载时”（即系统启动的`init_module`函数中），确保预分配在 “安全时机” 完成，规避内核权限风险。

#### 2. “多子池 + 全局指针” 的访问控制

为适配 VCS 项目中 “误差表存储、插值计算、补偿值输出” 三类不同数据需求，你设计了 “3 个子内存池”，并通过**全局指针**直接访问，进一步降低耗时：

```c
// 项目中可能的代码逻辑（伪代码）
// 1. 定义3个子内存池的全局指针（初始化后指向预分配的内存地址）
struct VCS_Table_Buf *g_vcs_table_pool;  // 误差表数据池
struct Interp_Tmp *g_interp_pool;        // 插值中间缓存池
struct Comp_Out_Buf *g_comp_out_pool;    // 补偿值输出池

// 2. 初始化时为指针分配预申请内存
void vcs_mem_pool_init() {
    // 调用内核接口预分配内存
    g_vcs_table_pool = hnc_mem_alloc(sizeof(struct VCS_Table_Buf));
    g_interp_pool = hnc_mem_alloc(sizeof(struct Interp_Tmp));
    g_comp_out_pool = hnc_mem_alloc(sizeof(struct Comp_Out_Buf));
    // 初始化空闲链表（固定大小子块，直接标记为空闲）
    init_free_list(g_vcs_table_pool, sizeof(double), 10020);  // 10020个double子块
}

// 3. 业务模块直接通过全局指针访问，无需分配
void chan_comp_calcu(Bit16 ch_no) {
    // 直接使用预分配的插值缓存池存储数据，无动态分配
    g_interp_pool->num[ch_no] = calculate_num(Pos, Start, Dist);  // 项目中插值公式
    g_interp_pool->weight[ch_no] = calculate_weight(Pos, Start);
}
```

#### 3. 无锁设计（适配内核实时任务）

华中 8 型系统的 “补偿任务” 是**单线程实时调度**（优先级最高，无其他线程抢占），因此你在内存池设计中 “省略锁机制”（如`mutex`），分配 / 释放时直接操作 “空闲链表”，避免锁的 “上下文切换耗时”（锁操作通常需几十微秒），确保补偿计算总耗时≤0.5ms。
